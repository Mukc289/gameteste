<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Ходилка — Викторина (2 игрока)</title>
<style>
body { margin:0; font-family: Arial,sans-serif; display:flex; justify-content:center; background:#222; }
canvas { display:block; background:#222; }
</style>
</head>
<body>
<canvas id="gameCanvas" width="900" height="600"></canvas>
<script>
const CONFIG = {
    cellRadius: 8,
    playerRadius: 15,
    sidebarPadding: 20,
    lineHeight: 35,
    btnSpacing: 15, // Это значение будет переопределено в drawQuiz
    btnHeight: 40,
    quizPadding: 20,
    borderWidth: 4
};

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

const GAME_W = 650;
const HEIGHT = 600;
const SIDEBAR_W = 250;

const cells = [
    {x:550, y:540}, {x:350, y:500}, {x:323, y:444},
    {x:375, y:355}, {x:240, y:380}, {x:150, y:340},
    {x:300, y:300}, {x:400, y:250}, {x:320, y:230}
];

const QUIZ_QUESTIONS = [
    ["Сколько лап у кошки?", ["2","4","6"], 1],
    ["Столица Франции?", ["Лондон","Париж","Берлин"], 1],
    ["Сколько месяцев в году?", ["6","12","18"], 1],
    ["Какая планета ближе к Солнцу?", ["Марс","Венера","Меркурий"], 2],
    ["Какой цвет неба?", ["Зелёный","Синий","Красный"], 1],
    ["2+2?", ["3","4","5"], 1],
    ["Сколько ног у паука?", ["6","8","10"], 1],
    ["Какой год високосный?", ["2021","2024","2023"], 1],
    ["Сколько дней в неделе?", ["5","6","7"], 2]
];

const players = [
    { pos: 0, score: 0, color: "red" },
    { pos: 0, score: 0, color: "blue" }
];

let currentPlayer = 0;
let quizActive = false;
let quizQuestion = "";
let quizOptions = [];
let quizCorrect = 0;
let needsRedraw = true;
let answerRects = [];
let hoverIndex = -1;
let quizVisited = [
    new Array(cells.length).fill(false),
    new Array(cells.length).fill(false)
];
let notification = "";
let gameOver = false;
let quizProcessing = false;

// Фоны (Проверьте, что расширения .jpg соответствуют вашим файлам)
const bgImage = new Image(); bgImage.src="field.jpg"; let bgLoaded=false; bgImage.onload=()=>{bgLoaded=true; needsRedraw=true;};
const sidebarBg = new Image(); sidebarBg.src="sidebar_quiz_bg.jpg"; let sidebarLoaded=false; sidebarBg.onload=()=>{sidebarLoaded=true; needsRedraw=true;};
const quizBgImage = new Image(); quizBgImage.src="quiz_panel_bg.jpg"; let quizBgLoaded=false; quizBgImage.onload=()=>{quizBgLoaded=true; needsRedraw=true;};
const btnDefaultBgImage = new Image(); btnDefaultBgImage.src="btn_default_bg.jpg"; let btnDefaultBgLoaded=false; btnDefaultBgImage.onload=()=>{btnDefaultBgLoaded=true; needsRedraw=true;};
const btnHoverBgImage = new Image(); btnHoverBgImage.src="btn_hover_bg.jpg"; let btnHoverBgLoaded=false; btnHoverBgImage.onload=()=>{btnHoverBgLoaded=true; needsRedraw=true;};
const btnCorrectBgImage = new Image(); btnCorrectBgImage.src="btn_correct_bg.jpg"; let btnCorrectBgLoaded=false; btnCorrectBgImage.onload=()=>{btnCorrectBgLoaded=true; needsRedraw=true;};


// ----------------- Функции -----------------
function resetGame(){
    players.forEach(p=>{p.pos=0;p.score=0;});
    currentPlayer=0;
    quizVisited=[new Array(cells.length).fill(false), new Array(cells.length).fill(false)];
    quizActive=false;
    notification="";
    gameOver=false;
    quizProcessing=false;
    hoverIndex=-1;
    answerRects=[];
    needsRedraw=true;
}

function movePlayer(steps){
    if(gameOver || quizProcessing) return;

    const player = players[currentPlayer];
    player.pos += steps;

    if(player.pos >= cells.length){
        player.pos = cells.length -1;
        
        // Устанавливаем уведомление о завершении игры
        notification=`Игрок ${currentPlayer+1} закончил игру! Счёт: ${player.score}.`;
        
        // Проверяем, закончили ли все игроки (сейчас только два)
        if (players[0].pos >= cells.length -1 && players[1].pos >= cells.length -1) {
             gameOver=true;
             quizActive=false;
        } else {
            // Если не все закончили, просто меняем ход
            currentPlayer=(currentPlayer+1)%2; 
        }

        needsRedraw=true;
        return;
    }

    if(!quizVisited[currentPlayer][player.pos]){
        quizActive=true;
        const idx = Math.floor(Math.random()*QUIZ_QUESTIONS.length);
        [quizQuestion, quizOptions, quizCorrect] = QUIZ_QUESTIONS[idx];
        answerRects=[];
        quizVisited[currentPlayer][player.pos]=true;
    }
    needsRedraw=true;
}

function drawText(text,color,x,y,maxWidth,lineHeight){
    const words=text.split(' '); let line='',lines=[];
    for(const word of words){
        const testLine = line? line+' '+word : word;
        const width = ctx.measureText(testLine).width;
        if(width<=maxWidth) line=testLine; else {lines.push(line); line=word;}
    }
    lines.push(line);
    lines.forEach((l,i)=>{ctx.fillStyle=color; ctx.fillText(l,x,y+i*lineHeight);});
    return lines.length;
}

function drawGameField(){
    // УВЕЛИЧИВАЕМ ШИРИНУ, ЧТОБЫ ПЕРЕКРЫТЬ ВОЗМОЖНЫЙ ЗАЗОР
    const fieldDrawWidth = GAME_W + 5; 

    if(bgLoaded) {
        ctx.drawImage(bgImage,0,0,fieldDrawWidth,HEIGHT);
    } else {
        ctx.fillStyle="#888"; 
        ctx.fillRect(0,0,fieldDrawWidth,HEIGHT);
    }

    ctx.fillStyle="white";
    cells.forEach(c=>{ctx.beginPath(); ctx.arc(c.x,c.y,CONFIG.cellRadius,0,Math.PI*2); ctx.fill();});

    players.forEach((player,idx)=>{
        const {x:px, y:py}=cells[player.pos];
        ctx.shadowColor="rgba(0,0,0,0.5)";
        ctx.shadowBlur=10;
        ctx.fillStyle=player.color;
        ctx.beginPath();
        ctx.arc(px,py,CONFIG.playerRadius,0,Math.PI*2);
        ctx.fill();
        ctx.shadowBlur=0;
        ctx.strokeStyle="black";
        ctx.lineWidth=CONFIG.borderWidth;
        ctx.stroke();

        ctx.fillStyle="white";
        ctx.font="12px Arial";
        ctx.textAlign="center";
        ctx.textBaseline="middle";
        ctx.fillText(idx+1,px,py);
    });
}

function drawSidebar(){
    // --- ФОН САЙДБАРА ---
    if(sidebarLoaded) { 
        ctx.drawImage(sidebarBg, GAME_W, 0, SIDEBAR_W, HEIGHT);
    } else {
        ctx.fillStyle="rgba(240, 240, 240, 0.9)"; 
        ctx.fillRect(GAME_W, 0, SIDEBAR_W, HEIGHT);
    }

    const padding=CONFIG.sidebarPadding; 
    const lineHeight=CONFIG.lineHeight;
    const center_x = GAME_W + SIDEBAR_W / 2; // Центр сайдбара
    
    ctx.textAlign="center"; 
    ctx.textBaseline="top";

    let sy=padding + 20; // Сдвиг текста вниз
    
    // --- ЦВЕТОВЫЕ КОНСТАНТЫ ДЛЯ СТИЛЯ ---
    const FONT_FAMILY = "'Times New Roman', serif";
    const COLOR_BLACK = "black"; // Черный цвет для текста
    
    // 1. ХОД ИГРОКА (Крупный, Чёрный)
    ctx.font = `20px ${FONT_FAMILY}`; 
    drawText(`ХОД ИГРОКА ${currentPlayer+1}`, COLOR_BLACK, center_x, sy, SIDEBAR_W-2*padding, 25); 
    sy += lineHeight + 15;

    // 2. СЧЕТ КРАСНОГО ИГРОКА (Красный)
    ctx.font = `14px ${FONT_FAMILY}`;
    ctx.fillStyle = players[0].color; // Красный
    ctx.fillText(`СЧЁТ КРАСНОГО:`, center_x, sy);
    sy += 18;
    ctx.font = `24px ${FONT_FAMILY}`;
    ctx.fillText(`${players[0].score}`, center_x, sy);
    sy += 30 + 10; // Отступ

    // 3. СЧЕТ СИНЕГО ИГРОКА (Синий)
    ctx.font = `14px ${FONT_FAMILY}`;
    ctx.fillStyle = players[1].color; // Синий
    ctx.fillText(`СЧЁТ СИНЕГО:`, center_x, sy);
    sy += 18;
    ctx.font = `24px ${FONT_FAMILY}`;
    ctx.fillText(`${players[1].score}`, center_x, sy);
    sy += 30 + 30; // Большой отступ
    
    // Определяем, достиг ли текущий игрок финиша (последняя клетка)
    const currentPlayerFinished = players[currentPlayer].pos >= cells.length - 1;

    // 4. ПОДСКАЗКА ДЕЙСТВИЯ (Черный)
    ctx.font = `16px ${FONT_FAMILY}`;
    // Подсказка показывается ТОЛЬКО если игра НЕ окончена И текущий игрок ЕЩЕ НЕ НА ФИНИШЕ И нет активной викторины
    if(!gameOver && !quizActive && !currentPlayerFinished) {
        drawText("Нажмите SPACE для хода", COLOR_BLACK, center_x, sy, SIDEBAR_W-2*padding, lineHeight); 
    }
    sy += lineHeight + 5;
    
    // 5. УВЕДОМЛЕНИЕ О РЕЗУЛЬТАТЕ (Черный)
    ctx.font = `16px ${FONT_FAMILY}`;
    if(notification) drawText(notification, COLOR_BLACK, center_x, sy, SIDEBAR_W-2*padding, lineHeight);
}

function drawQuiz(){
    if(!quizActive) return;
    const pw=400,ph=200;
    const pxw=(GAME_W-pw)/2, pyw=(HEIGHT-ph)/2;
    
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    
    if(quizBgLoaded) {
        ctx.drawImage(quizBgImage, pxw, pyw, pw, ph);
        ctx.fillStyle="rgba(255, 255, 255, 0.2)"; 
        ctx.fillRect(pxw,pyw,pw,ph);
    } else {
        ctx.fillStyle="rgba(240, 240, 240, 0.9)"; 
        ctx.fillRect(pxw,pyw,pw,ph);
    }
    
    // --- ТЕКСТ ВОПРОСА ---
    ctx.textAlign="center"; 
    ctx.textBaseline="top";
    
    const FONT_FAMILY = "'Times New Roman', serif"; // Используем тот же шрифт
    
    ctx.fillStyle="black"; 
    // Шрифта вопроса сделан жирным, serif и увеличен до 20px
    ctx.font=`bold 20px ${FONT_FAMILY}`; 
    
    const questionY = pyw + CONFIG.quizPadding + 10;
    const lineCount = drawText(quizQuestion,"black",pxw+pw/2, questionY, pw-2*CONFIG.quizPadding, 25);

    // --- ПАРАМЕТРЫ КНОПОК ---
    // Убираем отступы между кнопками
    const BTN_SPACING = 0; 
    
    // Отступ от краев рамки
    const BTN_SIDE_PADDING = 15; 
    const btnOffset = CONFIG.quizPadding + BTN_SIDE_PADDING;
    
    let btnHeight=CONFIG.btnHeight;
    const btnSpacing=BTN_SPACING; // Используем новый, нулевой отступ
    const maxButtonsHeight=ph-2*CONFIG.quizPadding-lineCount*25; 
    const btnTotalHeight = quizOptions.length*(btnHeight+btnSpacing)-btnSpacing;
    
    if(btnTotalHeight > maxButtonsHeight) {
        btnHeight = (maxButtonsHeight - (quizOptions.length-1)*btnSpacing) / quizOptions.length;
    }
    btnHeight = Math.max(20, btnHeight);
    
    // Новая начальная Y-координата для кнопок: 
    // +5 - минимальный отступ после текста вопроса (чтобы поднять их выше)
    const startY=questionY + lineCount*25 + 5; 
    answerRects=[];

    quizOptions.forEach((opt,i)=>{
        const rect={
            x: pxw + btnOffset, 
            y: startY + i*(btnHeight+btnSpacing), 
            w: pw - 2 * btnOffset, 
            h: btnHeight
        };
        answerRects.push(rect);
        
        let currentBtnBgImage = btnDefaultBgImage;
        let currentBtnBgLoaded = btnDefaultBgLoaded;

        if (i === hoverIndex) {
            currentBtnBgImage = btnHoverBgImage;
            currentBtnBgLoaded = btnHoverBgLoaded;
        }

        if (currentBtnBgLoaded) {
            ctx.drawImage(currentBtnBgImage, rect.x, rect.y, rect.w, rect.h);
        } else {
            ctx.fillStyle=(i===hoverIndex)?"rgba(200, 200, 200, 1)":"rgba(230, 230, 230, 1)"; 
            ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
        }
        
        // СТИЛЬ ТЕКСТА КНОПКИ (Белый, Arial - оставлен для читаемости)
        ctx.fillStyle="white"; 
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        ctx.font = "14px Arial"; 
        
        ctx.fillText(
            `${i+1}. ${opt}`, 
            rect.x+10, 
            rect.y + rect.h / 2
        );
    });
}

function showCorrectAnswer(i){
    if(i<0||i>=answerRects.length) return;
    const rect=answerRects[i];
    
    if(btnCorrectBgLoaded) {
        ctx.drawImage(btnCorrectBgImage, rect.x, rect.y, rect.w, rect.h);
        ctx.fillStyle="rgba(0, 255, 0, 0.2)"; 
        ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
    } else {
        ctx.fillStyle="#7CFC00"; 
        ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
    }
    
    // СТИЛЬ ТЕКСТА КНОПКИ (Белый)
    ctx.fillStyle="white";
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    ctx.font = "14px Arial"; 
    
    ctx.fillText(
        `${i+1}. ${quizOptions[i]}`, 
        rect.x+10, 
        rect.y + rect.h / 2
    );
}

function handleAnswer(i){
    if (quizProcessing) return; 

    quizProcessing=true;
    hoverIndex = -1; 
    
    if(i === quizCorrect){
        showCorrectAnswer(i);
        draw(); 
        players[currentPlayer].score++;
        setTimeout(()=>{
            quizActive=false; 
            quizProcessing=false; 
            notification="Правильный ответ! Ход переходит к сопернику.";
            
            // Если игрок дошел до конца, не меняем ход, а проверяем условие завершения
            if (players[currentPlayer].pos < cells.length - 1) {
                currentPlayer=(currentPlayer+1)%2;
            } else {
                 // Если текущий игрок уже финишировал, но игра не закончена, просто передаем ход
                 if (!gameOver) currentPlayer=(currentPlayer+1)%2;
            }
            
            needsRedraw=true;
        },1500); 
    } else {
        showCorrectAnswer(quizCorrect);
        draw(); 
        setTimeout(()=>{
            quizActive=false; 
            quizProcessing=false;
            currentPlayer=(currentPlayer+1)%2;
            notification="Неверно! Ход переходит сопернику.";
            needsRedraw=true;
        },1500); 
    }
}

function drawGameOverScreen(){
    if(!gameOver) return;

    // Затемнение поля
    ctx.fillStyle = "rgba(0, 0, 0, 0.7)"; 
    ctx.fillRect(0, 0, GAME_W, HEIGHT);

    // Центр поля
    const center_x = GAME_W / 2;
    const center_y = HEIGHT / 2;

    // Определение победителя
    const p1 = players[0];
    const p2 = players[1];
    let winnerText;
    let winnerColor;

    if (p1.score > p2.score) {
        winnerText = `ПОБЕДИЛ ИГРОК 1! Счет: ${p1.score}`;
        winnerColor = p1.color;
    } else if (p2.score > p1.score) {
        winnerText = `ПОБЕДИЛ ИГРОК 2! Счет: ${p2.score}`;
        winnerColor = p2.color;
    } else {
        winnerText = `НИЧЬЯ! Счет: ${p1.score} - ${p2.score}`;
        winnerColor = "#FFFACD"; // Светлый кремовый
    }

    // --- Надпись "ИГРА ОКОНЧЕНА" ---
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = "bold 40px 'Times New Roman', serif";
    ctx.fillStyle = "#FFFACD"; // Светло-кремовый
    ctx.fillText("ИГРА ОКОНЧЕНА", center_x, center_y - 50);

    // --- Надпись Победителя ---
    ctx.font = "bold 50px 'Times New Roman', serif";
    ctx.fillStyle = winnerColor;
    ctx.fillText(winnerText, center_x, center_y + 20);

    // --- Подсказка ---
    ctx.font = "20px 'Times New Roman', serif";
    ctx.fillStyle = "white";
    ctx.fillText("Нажмите R для новой игры", center_x, center_y + 100);
}


// ----------------- События -----------------
canvas.addEventListener("click", e=>{
    if(!quizActive || quizProcessing) return;
    const rect = canvas.getBoundingClientRect();
    const mx=e.clientX-rect.left;
    const my=e.clientY-rect.top;
    answerRects.forEach((r,i)=>{ if(mx>=r.x && mx<=r.x+r.w && my>=r.y && my<=r.y+r.h) handleAnswer(i); });
});

canvas.addEventListener("mousemove", e=>{
    if(!quizActive){hoverIndex=-1; needsRedraw=true; return;} 
    const rect=canvas.getBoundingClientRect();
    const mx=e.clientX-rect.left; const my=e.clientY-rect.top;
    const prevHover=hoverIndex; hoverIndex=-1;
    answerRects.forEach((r,i)=>{if(mx>=r.x && mx<=r.x+r.w && my>=r.y && my<=r.y+r.h) hoverIndex=i;});
    if(prevHover!==hoverIndex) needsRedraw=true;
});

window.addEventListener("keydown", e=>{
    if(e.code==='KeyR'){ resetGame(); return;}
    
    if(quizActive && !quizProcessing){
        if(e.key==='1'||e.key==='2'||e.key==='3'){ 
            handleAnswer(parseInt(e.key)-1);
        }
    } else if(!quizProcessing && !gameOver){
        // Дополнительная проверка: если текущий игрок не финишировал
        const currentPlayerFinished = players[currentPlayer].pos >= cells.length - 1;
        
        if(e.code==='Space' && !currentPlayerFinished){ 
            movePlayer(1); 
            
            // Смена игрока, если не началась викторина и игра не закончилась
            if(!quizActive && !gameOver) { 
                currentPlayer=(currentPlayer+1)%2; 
            }
            needsRedraw=true;
        }
    }
});

// ----------------- Главный цикл -----------------
function gameLoop(){ draw(); requestAnimationFrame(gameLoop);}
function draw(){ 
    if(!needsRedraw) return; 
    
    ctx.clearRect(0,0,canvas.width,canvas.height); 
    drawGameField(); 
    drawSidebar(); 
    drawQuiz(); 
    drawGameOverScreen(); // Рисуем финальный экран поверх всего
    
    needsRedraw=false;
}
gameLoop();
</script>
</body>
</html>